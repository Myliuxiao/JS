##  面向对象编程（Object Oriented Programming）

### 单例设计模式（Singleton Pattern）

##### `表现形式:`

```javascript
var obj = {
	xxx:xxx,
	...
};
```

> ###### 在单例设计模型中，obj不仅仅是对象名，它被称为“命名空间[NameSpace]”，把描述事物的属性存放到命名空间中，多个命名空间是独立分开的，互补冲突 

##### `单例模式解决的问题`

> 把描述同一件事物的属性和特征进行“分组、归类”，（）存储在同一个堆内存空间中，避免了全局变量之间的冲突和污染

##### `单例设计模式命名的由来`

> 每一个命名空间都是JS中Object这个内置基类的实例，而实例之间是相互独立互补干扰的，所以我们称 “单独的实例”

#### 高级单例模式

```javascript
var nameSpace = (function() {
	var n = 12;
    function fn() {
        
    }
    return{
        fn:fn
    }
})();
```

> 在给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域（不销毁的栈内存），在私有作用域中创建一个堆内存，把堆内存地址赋值给命名空间

#### 单例实际设计模式的好处

> 我们完全可以在私有作用域中创造很多内容（变量和函数），那些需要供外面使调取使用的，我们暴露到返回的对象中（模块化实现的一种思想）

#### 强化高级单例模式

``习题``

```javascript
var n =2;
var obj = {
    n:3,
    fn:(function (n){
        n* = 2;
        this.n+=2;
        var n = 5;
        return function(m){
            this.n*2;
            console.log(m+(++n));
        }
    })(obj.n)
};
var fn = obj.fn;
fn(3);
obj.fn(3);
console.log(n,obj.n);
```

`this`

1.给当前元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素对象



2.普通函数执行，函数中的this取决于执行的主体，谁执行的，this就是谁(执行主体：方法执行，看方法名前面是否有点·，有的话，点前面是谁就是谁，如果没有，this就是window)

#### 基于单例设计模式实现项目的模块化

> 1.团队协作开发的时候，会把产品按照功能板块进行划分，每一个功能板块有专人负责开发
>
> 2.把各个板块之间公用的部门进行提取封装，后期再实现这些功能直接的调取引用即可（模块封装）

#### 工厂模式（Factory Pattern）

> 
>
> 



### OOP

##### `面向对象`

> JS\JAVA\PHP\C#\Ruby\Python\C++...

##### `面向过程`

> C

##### 面向对象编程，需要我们掌控: "对象、类、实例"的概念

- 对象：万物皆对象
- 类：对象的具体细分（按照功能特点进行分类：大类、小类）
- 实例：类中具体的事物（拿出类别中的具体一个类别进行研究，那么当前类别下的其他实例也具备这些特点和特征 ）

##### 整个JS就是基于面向对象设计和开发出来的语言，我们学习和实战的时候也要按照面向对象的思想去体会和理解

`JS中的内置“类”`

> - Object  对象类（基类）
>   - Number (0 NaN 1.2 ...) 都是数字类的实例
>   - String
>   - Boolean
>   - Null
>   - Undefined
>   - Array
>   - RegExp
>   - function
>   - Date
>   - ...

##### 基于基类我们可以创建很多属于我们自己的类

##### 基于构造函数创建自定义类（constructor） 

> 1.在普通函数执行的基础上"new xxx ()"，这样就不是普通函数执行了，而是构造函数执行，当前的函数名称之为“类名”，接收的返回结果是当前类的一个实例
>
> ```javascript
> var f = new Fn();  //Fn是类 f是类的一个实例
> ```
>
> 2.创建的类名，最好第一个单词首字母大写
>
> 3.这种构造函数设计模式执行，主要用于组件、类库、插件、框架等的封装，平时编写业务逻辑一般不这样处理

#### JS中创建值有两种方式

- 字面量表达式     var obj = {};    基本类型
- 构造函数模式     var obj = new Object();  引用类型  

不管哪一种方式创造出来的都是Object类的实例，而实例之间是独立分开的，所以var xxx = { }这种模式就是JS中的单例模式

### 构造函数执行过程

1.像普通函数一样，形成一个私有作用域（栈内存）

- 形参赋值
- 变量提升 

2.构造函数执行独有：在JS代码自上而下执行之前，首先在当前形成的私有栈中创建一个对象（创建一个堆内存：暂时不存储任何的东西），并且让函数中的执行主体（this）指向这个新的堆内存（this===创建的对象）

3.代码开始自上而下执行

4.构造函数执行独有：代码执行完成，把之前创建的堆内存地址返回（浏览器默认返回）

##### ``小总结`` 

> ##### 也就是开始创建的对象其实就是当前Fn这个类的一个实例，我们让this指向这个实例，代码执行中this.xxx=xxx都是给实例设置“私有属性”，最后浏览器会把默认创建的实例返回，供外面接收。
>
> ###### 再次执行new Fn，就是把上面的操作克隆一份，会形成新的实例（新的内存空间），所以说实例是独立分开的

##### **``小细节``**

> 构造函数执行，不写return。浏览器会默认返回创建的实例，但是我们自己写了return？
>
> 1. return是一个基本值，返回的结果依然是类的实例，没有受到影响
> 2. 如果返回的是引用值，则会把默认返回的实例覆盖，此时接收到的结果就不再是当前类的实例了

###### 构造函数执行的时候，尽量减少return的使用，防止覆盖实例

### 原型（prototype）和原型链（_ proto _）

[函数]

​	普通函数、类（所有的类：内置类、自己创建的类）

[对象]

​	 普通对象、数组、正则、Math、arguments、实例是对象类型的（除了基本类型的字面量创建 				               						   的值）、prototype的值也是对象类型的、函数也是对象（万物皆对象）

### 理解并记忆

> 1. 所有的函数数据类型都自带一个属性：prototype（原型），这个属性的值是一个对象，浏览器会默认给它开辟一个堆内存
> 2. 在浏览器给prototype开辟的堆内存中有一个自带的属性：constructor，这个属性存储的值是当前函数本身
> 3. 每一个对象都有一个_ proto _的属性，这个属性指向当前实例所属类的prototype（如果不能确定它是谁的实例，都是Object的实例）

每一个类都把供实例调取的公共属性方法，存储到自己的原型上（原型prototype的作用就是存储一些公共的属性和方法，供它的实例调取使用 ）  

![1563193790861](D:\WEB全栈笔记\img\1563193790861.png)

##### 原型链：

它是一种基于__ proto __向上查找的机制。当我们操作实例的某个属性或者方法的时候，首先找自己空间中私有的属性或者方法

1.找到了，则技术查找，使用自己私有的即可

2.没有找到，则基于__ proto__ 找所属类的原型（prototype），如果找到就用这个公有的，如果没找到，基于原型上的  __ proto __继续向上查找，一直找到Object.prototype的原型为止，如果再没有，操作的属性或者方法不存在 