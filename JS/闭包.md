### 闭包概念

函数执行形成一个私有的作用域，保护里面的私有变量不受外界的干扰，这种保护机制称之为“闭包”

正常闭包说法：

形成一个不销毁的私有作用域（私有栈内存）才叫闭包，不仅可以保护里面的私有变量不受外界的干扰，还可以在这个不销毁的私有栈内存中存储一些数据，供后期调取使用

 ```javascript
 //=> 闭包 ：柯里化函数
 function fn () {
     return function () {
         
     }
 }
 var f = fn ();
 // =>闭包：惰性函数
 var utils = (function () {
     return{
         
     }
 })();
 ```



### 闭包的项目实战应用

缺点：真实项目中为了保证JS的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）

###### 作用：

 - 闭包具有保护作用：保护私有变量不受外界的干扰

   - 在真实项目中，尤其是团队协作开发的时候，应当尽可能的减少全局变量的使用，以防止相互之间的冲突（全局变量污染），那么此时我们完全可以把自己这一部分内容封装到一个闭包中，让全局变量转化为私有变量

     ```javascript
     (function (){
         var n = 12;
         function fn(){
             
         }
         //...
      })(); 
     ```

   - 不仅如此，我们封装库插件的时候，也会把自己的程序都存放到闭包中保护起来，防止和用户的程序冲突，但是我们又需要暴露一些方法给客户使用，这样我们如何处理呢？

     - JQ这种方式：把需要暴露的方法抛到全局
     - Zepto这种方式：基于return把需要供外面使用的方法暴露出去

        ```javascript
     var Zepto = (function (){
         //...
         return{
             xxx:function (){
                 
             }
         };
     })();
     Zepto.xxx(); 

        ```

     ​

- 闭包具有保存作用：形成不销毁的栈内存，把一些值保存下来，方便后面的调取使用

```javascript
//使用一个实例来了解
for (var i = 0; i < tabList.length; i++) {
    //每执行一次循环都会形成一个不销毁的私有作用域
    tabList[i].onclick = (function (n) {  //使用自执行函数，让每一次循环都生成一个私有作用域
        var i = n;
        return function () {
            chengeTab(i)
        }
    })(i)  //每次循环都会把对应的i（0）传入到函数中，保证了i的值得到了存储
}
```



##### 在传统ES中，只有全局作用域（window）和私有作用域（function执行产生的），判断和循环不会产生作用域
 